"""
Data models for Planner Arm service.

This module contains Pydantic models for API requests/responses and planning data structures.
"""

from typing import Any
from uuid import uuid4

from pydantic import BaseModel, Field, field_validator


class SubTask(BaseModel):
    """
    A single step in the execution plan.

    Represents one actionable task with clear acceptance criteria and dependencies.
    """

    step: int = Field(..., ge=1, description="Step number (1-based)")
    action: str = Field(..., min_length=10, max_length=500, description="What to do")
    required_arm: str = Field(..., description="Which arm executes this")
    acceptance_criteria: list[str] = Field(
        ..., min_length=1, max_length=5, description="Success conditions"
    )
    depends_on: list[int] = Field(default_factory=list, description="Prerequisite step numbers")
    estimated_cost_tier: int = Field(1, ge=1, le=5, description="Cost tier (1=cheap, 5=expensive)")
    estimated_duration_seconds: int = Field(30, ge=1, description="Estimated time in seconds")

    @field_validator("required_arm")
    @classmethod
    def validate_arm(cls, v: str) -> str:
        """Ensure arm is one of the known arms."""
        allowed_arms = ["planner", "retriever", "coder", "executor", "judge", "guardian"]
        if v not in allowed_arms:
            raise ValueError(f"required_arm must be one of {allowed_arms}, got '{v}'")
        return v

    @field_validator("acceptance_criteria")
    @classmethod
    def validate_acceptance_criteria(cls, v: list[str]) -> list[str]:
        """Ensure acceptance criteria are non-empty strings."""
        if not v:
            raise ValueError("acceptance_criteria must not be empty")
        for criterion in v:
            if not criterion or not criterion.strip():
                raise ValueError("acceptance_criteria must contain non-empty strings")
        return v


class PlanResponse(BaseModel):
    """
    Complete execution plan generated by the Planner Arm.

    Contains ordered subtasks, rationale, and metadata about the plan.
    """

    plan: list[SubTask] = Field(..., min_length=1, max_length=15, description="Ordered subtasks")
    rationale: str = Field(..., min_length=10, max_length=1000, description="Why this approach")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Confidence in plan (0.0-1.0)")
    total_estimated_duration: int = Field(..., ge=1, description="Total time in seconds")
    complexity_score: float = Field(
        ..., ge=0.0, le=1.0, description="Plan complexity (0.0=simple, 1.0=complex)"
    )

    @field_validator("plan")
    @classmethod
    def validate_plan(cls, v: list[SubTask]) -> list[SubTask]:
        """Validate plan structure and dependencies."""
        if not v:
            raise ValueError("Plan must contain at least one subtask")

        # Check step numbering is sequential
        for idx, subtask in enumerate(v):
            expected_step = idx + 1
            if subtask.step != expected_step:
                raise ValueError(
                    f"Step numbers must be sequential. Expected {expected_step}, got {subtask.step}"
                )

        # Check dependencies reference valid steps
        step_numbers = {subtask.step for subtask in v}
        for subtask in v:
            for dep in subtask.depends_on:
                if dep not in step_numbers:
                    raise ValueError(f"Step {subtask.step} depends on non-existent step {dep}")
                if dep >= subtask.step:
                    raise ValueError(
                        f"Step {subtask.step} cannot depend on later or same step {dep}"
                    )

        return v


class PlanRequest(BaseModel):
    """
    Incoming planning request from the Orchestrator.

    Contains the goal, constraints, and context needed to generate a plan.
    """

    goal: str = Field(..., min_length=10, max_length=10000, description="What to accomplish")
    constraints: list[str] = Field(
        default_factory=list, max_length=20, description="Hard constraints"
    )
    context: dict[str, Any] = Field(default_factory=dict, description="Background information")
    request_id: str = Field(
        default_factory=lambda: str(uuid4()), description="Unique request identifier"
    )

    @field_validator("goal")
    @classmethod
    def validate_goal(cls, v: str) -> str:
        """Ensure goal is meaningful."""
        if not v or not v.strip():
            raise ValueError("Goal must be a non-empty string")
        return v.strip()


class HealthResponse(BaseModel):
    """Health check response."""

    status: str = Field(..., description="Health status")
    version: str = Field(..., description="Service version")
    model: str = Field(..., description="LLM model in use")
    timestamp: str = Field(..., description="Current timestamp")


class ReadinessResponse(BaseModel):
    """Readiness check response."""

    ready: bool = Field(..., description="Service readiness status")
    checks: dict[str, bool] = Field(..., description="Individual readiness checks")


class CapabilitiesResponse(BaseModel):
    """Arm capabilities response."""

    arm_id: str = Field(..., description="Arm identifier")
    capabilities: list[str] = Field(..., description="List of capabilities")
    cost_tier: int = Field(..., ge=1, le=5, description="Cost tier")
    average_latency_ms: int = Field(..., ge=0, description="Average latency in milliseconds")
    success_rate: float = Field(..., ge=0.0, le=1.0, description="Historical success rate")
